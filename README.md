# seckill
# 项目架构：
项目主要涉及的技术点：springboot+mybatis+myqsl+redis+rabbitmq，主要实现的功能有用户登录，商品列表查询，商品详情查询，商品秒杀，订单详情查询，商品支付和充值功能。其中redis有5个功能：
## 第一，用于分布式session，在用户首次登录的时候通过uuid类生成一个token值保存在浏览器的cookie中，同时在redis中防置前缀为userkey，后缀为token字段的key值，value值为user的用户信息。当下次用户请求登陆时，如果后端能在redis中拿到对应token值的key，就不用查询mysql数据库验证身份，减少对数据库的请求压力。
## 第二，redis还用于缓存用户访问过的html页面。下次用户请求该页面的时候，如果redis还存有页面的代码缓存，就可以直接从redis中取出。这一步是通过thymeleafViewResolver手动解析页面代码成string字符串实现的。
## 第三，redis还用于存储商品的具体库存信息，进行redis库存预减，如果redis库存预减失败，就不会从mysql数据库中再进行数据操作。其中秒杀操作的controller继承了InitializingBean接口，通过其中的afterPropertiesSet()方法，在springboot初始化bean的时候就进入mysql查询各个商品的库存数量加载进redis，方便后续操作。
## 第四，redis还用于放置秒杀路径。秒杀路径的作用在于对每个用户对每个商品的每次请求生成一个唯一的秒杀路径字符串，不然如果每个用户都始终对应唯一的秒杀路径会被别的用户抓包窃取盗刷商品。通过redis和uuid每次生成放置并检验秒杀路径，保证秒杀的安全性。
## 第五，redis还用于缓存订单信息，秒杀完毕生成订单以后，将订单信息放入redis，后续用户想要查询订单信息也从redis中走，防止mysql访问压力过大。
此外的话还有通过redis设置防刷接口，防止用户在秒杀的时候一值点击秒杀按键，对于后台的请求压力太大，但是这个放到后面再说。
还有mq，mq在项目中的作用主要是用于积压可能的大量秒杀消息，交给数据库去慢慢消费；异步回传给客户端，可以告知客户端秒杀请求的结果，并且继续帮助客户查询下单情况，但是项目这里前端没有实现异步告知客户端下单成功的功能，而是直接秒杀以后就进入查询订单信息的流程。
然后是一些其他的项目配置细节。
## 第一个是用户登录的手机号验证，这里是通过自定义注解+JSR303对提交的手机号和密码格式进行字段验证（主要是notnull注解和length注解）。自定义注解通过constraint限定方法进行数据格式验证，主要是对手机号进行模式匹配，查看其是否符合1开头并且长度为11位。
## 第二个是用户密码的加密处理。这里主要进行了两次md5加密处理，第一次md5加密用在前端的javascript函数里面，通过获取输入密码值进行md5加密传给后端，主要的作用是防止网络抓包获取到用户真实的登录密码；后续的md5加密出现在后端登录，主要的作用是防止用户密码太简单，数据库被盗以后，会通过一些md5数据库反推出密码。
## 第三个是后续的请求线程自动获取当前登录的用户信息。这里主要是使用了springboot拦截器的pre方法，当发现请求的方法为controller方法时，就会自动通过cookie字段中的token值取redis中的user信息，存进当前请求线程的本地线程变量中；同时定义一个自定义的参数解析器，参数解析器在分析完请求参数中含有User类型的请求参数就会自动执行参数解析方法，返回本地线程变量的user信息，controller方法就能直接获取到user信息了。
## 第四个是接口防刷。接口防刷的主要作用是防止用户的频繁点击对后台的请求处理压力太大。具体的实现是通过自定义注解，注解内部标定时间分段和时间分段内允许的最大点击次数。如果当前用户在时间分段内频繁点击进行秒杀，并且到了规定的最大点击次数（其中每一次点击都会让防刷接口在redis中保存的键值对应的数值加一），pre方法返回false，前端回传json字符串提示刷新太频繁，后端不会再进入controller方法。
上述的拦截器和参数解析器都要注册到webmvcconfigurer当中。
## 第五个是一些全局异常的处理，省去在controller方法体中大量使用try catch捕获异常。这里主要用到了springboot aop的思想，使用的是controlleradvice注解和其中的exceptionhandler注解，对捕获到的异常进行类别分析，返回异常信息。
